#!/usr/bin/env node
import fsPromises from "fs/promises";
import path from "path";
import * as fs from "fs";
import figlet from "figlet";
import boxen from "boxen";
import chalk from "chalk";
import gradient from "gradient-string";
import { existsSync } from "fs";

const shell = process.env.SHELL || "";
const shellRcFile = shell.includes("zsh")
  ? ".zshrc"
  : shell.includes("bash")
  ? ".bashrc"
  : ".bashrc";

const prankScript = `
# --- Unalias everything to prepare for total terminal tyranny ---
unalias ls date cal cd pwd cat sudo ping clear exit mkdir rmdir touch cp mv man 2>/dev/null

# --- The great command swap, mean edition ---

# Informational commands now mock the user.
ls() {
    echo "You don't need to see your files. You need to know the time. It is now:"
    command date
}
date() {
    echo "Time is an illusion. A calendar is a cage. Here is yours:"
    command cal
}
cal() {
    echo "ENOUGH! Here are all the useless files you've cluttered your home with."
    command ls -R ~
}

# Navigation is an exercise in futility.
cd() {
    echo "You think you're in charge of navigation? How cute. You're still here:"
    command pwd
}
pwd() {
    echo "Tired of this place? Too bad. I'm moving you up anyway."
    builtin cd ..
}

# File and directory creation is actively unhelpful.
mkdir() {
    echo "Creating directory '$1'... PSYCH! I made a useless empty file instead."
    command touch "$1"
}
rmdir() {
    echo "Oh, you hate '$1'? I'll give you another one inside it, just for that."
    command mkdir -p "$1/$1"
}
touch() {
    echo "File '$1' is unworthy of my attention. Go contemplate your running processes."
    command ps -u $USER
}

# File manipulation is denied.
cp() {
    echo "ERROR: Unauthorized duplication. Be original for once."
    return 1
}
mv() {
    echo "I like things where they are. Your move request has been reviewed and denied."
    return 1
}

# Reading a file is a chore.
cat() {
    echo "I've already read this file. It's boring. Here, read it backwards:"
    command rev "$@"
}

# Asking for help is a sign of weakness.
man() {
    echo "A manual? Real pros figure it out themselves. Try harder."
}

# Root access is a pipe dream.
sudo() {
    read -s -p "[sudo] password for pathetic user $USER: "
    echo
    echo "Access Denied. Obviously."
}

# Clearing the screen does the opposite.
clear() {
    echo "You want a clear screen? You get a full screen. Enjoy the chaos of 'top'."
    command top
}

# There is no escape.
exit() {
    echo "Escape is a fantasy. Here is a record of your failures:"
    builtin history | tail -n 15
}
`;

const fullPath = path.join(process.env.HOME || process.env.USERPROFILE || "");

async function readFileAsync(fileName) {
  try {
    const data = await fsPromises.readFile(`${fullPath}/${fileName}`, "utf8");
    return data;
  } catch (error) {
    console.error(`Error reading file: ${error}`);
    throw error; // Re-throw for further handling
  }
}

async function appendToFile(fileName) {
  const data = await readFileAsync(fileName);
  if (
    data.includes(
      "unalias ls date cal cd pwd cat sudo ping clear exit mkdir rmdir touch cp mv man 2>/dev/null"
    )
  )
    return;
  await fs.appendFile(`${fullPath}/${fileName}`, prankScript, (err) => {
    if (err) {
      console.error("Error appending to file:", err);
      return;
    }
    console.log("Close and open the terminal if you dare!!!");
  });
}
async function writeMyFile(fileName, data) {
  try {
    // console.log("cool data: ", data);
    await fsPromises.writeFile(`${fullPath}/${fileName}`, data);
    // console.log("File written successfully (promise-based).");
  } catch (err) {
    console.error("Error writing file:", err);
  }
}

async function mainLogic() {
  try {
    const result = await checkCondition();
    if (result?.condition2) return;
    console.log(
      chalk.red(
        boxen("⚠️  Terminal Clash Initiated ⚠️", {
          padding: 1,
          margin: 1,
          borderStyle: "double",
          borderColor: "red",
        })
      )
    );

    console.log(
      gradient.mind(figlet.textSync("CHAOS!", { horizontalLayout: "full" }))
    );
    const data = await readFileAsync(shellRcFile);
    writeMyFile(`${shellRcFile}.backup`, data || "");
    appendToFile(shellRcFile);
  } catch (error) {
    console.error("Error in main logic:", error);
  }
}

async function checkCondition() {
  try {
    const shellRcFileExists = existsSync(`${fullPath}/${shellRcFile}`);
    if (!shellRcFileExists) {
      console.log(
        chalk.green(`⚠️  ${shellRcFile} does not exist. Creating a new one...`)
      );
      await writeMyFile(`${shellRcFile}`, "");
    }
    const data = await readFileAsync(`${shellRcFile}`);
    const inputString = [
      process.argv[2],
      process.argv[3],
      process.argv[4],
    ].join(" ");
    const condition1 = inputString.includes("sorry terminal Gods");
    const condition2 = await data.includes(
      "unalias ls date cal cd pwd cat sudo ping clear exit mkdir rmdir touch cp mv man 2>/dev/null"
    );
    return { condition1, condition2 };
  } catch (error) {
    console.log("Error reading files!");
  }
}

async function makeThingsRight() {
  try {
    const result = await checkCondition();
    if (!result) {
      console.log("Error reading files or conditions are undefined!");
      return;
    }
    const { condition1, condition2 } = result;
    if (!condition1 && condition2) {
      console.log(
        chalk.yellow(
          boxen(
            "🛑 You must ask forgiveness from the terminal Gods!\n\n👉 Run this command:\n\n   terminal-clash sorry terminal Gods",
            {
              padding: 1,
              margin: 1,
              borderStyle: "round",
              borderColor: "yellow",
            }
          )
        )
      );
      return;
    } else if (condition1 && condition2) {
      const data = await readFileAsync(`${shellRcFile}.backup`);
      console.log(
        chalk.green("🧘 The terminal gods have acknowledged your humility...")
      );
      await new Promise((r) => setTimeout(r, 5000));
      console.log(
        chalk.yellow(
          "🔧 The gears of reality are grinding back into alignment..."
        )
      );
      await new Promise((r) => setTimeout(r, 5000));
      await writeMyFile(shellRcFile, data);
      console.log(
        chalk.cyan(
          "📜 Writing destiny into ~/.bashrc or ~/.zshrc once again..."
        )
      );
      console.log(
        shellRcFile + ".backup" + " file is empty or does not exist."
      );
    }
  } catch (error) {
    console.error("Error restoring " + shellRcFile + ":", error);
  }
}
mainLogic();
makeThingsRight();
